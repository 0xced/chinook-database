<#@ template hostspecific="True"#>
<#@ output extension="cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ include file="..\..\ChinookDatabase\_T4Templates\Chinook.ttinclude" #>
<#@ include file="..\..\ChinookDatabase\_T4Templates\Manager.ttinclude" #>
<#

var options = new [] {
						new Option
						{
							Name = "ChinookSqlServer",
							ConnectionClass = "SqlConnection",
							AdapterClass = "SqlDataAdapter",
							Namespace = "System.Data.SqlClient",
							ConnectionNames = new[] {"Chinook_SqlServer", "Chinook_SqlServer_AutoIncrement"}
						},
						new Option 
						{
							Name = "ChinookSqlServerCompact",
							ConnectionClass = "SqlCeConnection",
							AdapterClass = "SqlCeDataAdapter",
							Namespace = "System.Data.SqlServerCe",
							ConnectionNames = new[] {"Chinook_SqlServerCompact", "Chinook_SqlServerCompact_AutoIncrement"}
						},
						new Option 
						{
							Name = "ChinookMySql",
							ConnectionClass = "MySqlConnection",
							AdapterClass = "MySqlDataAdapter",
							Namespace = "MySql.Data.MySqlClient",
							ConnectionNames = new[] {"Chinook_MySql", "Chinook_MySql_AutoIncrement"}
						},
						new Option 
						{
							Name = "ChinookSqlite",
							ConnectionClass = "SQLiteConnection",
							AdapterClass = "SQLiteDataAdapter",
							Namespace = "Devart.Data.SQLite",
							ConnectionNames = new[] {"Chinook_Sqlite", "Chinook_Sqlite_AutoIncrement"}
						},
						new Option 
						{
							Name = "ChinookOracle",
							ConnectionClass = "OleDbConnection",
							AdapterClass = "OleDbDataAdapter",
							Namespace = "System.Data.OleDb",
							ConnectionNames = new[] {"Chinook_Oracle"}
						}
					};

var fileManager = Manager.Create(Host, GenerationEnvironment);

foreach (Option option in options)
{
	var connectionValues = option.GetConnectionValues();
	var className = option.Name + "Fixture";
	var filename = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), className + ".cs");
	fileManager.StartNewFile(filename);
	
#>/*******************************************************************************
 * Chinook Database - Version <#= DataSetHelper.GetVersionNumber() #>
 * Description: Test fixture for Chinook database.
 * DB Server: <#= option.Name #>
 * Author: Luis Rocha
 * License: http://www.codeplex.com/ChinookDatabase/license
 * 
 * IMPORTANT: In order to run these test fixtures, you will need to:
 *            1. Run the generated SQL script to create the database to be tested.
 *            2. Verify that app.config has the proper connection string (user/password).
 ********************************************************************************/
using System;
using System.Configuration;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using NUnit.Framework;
using <#= option.Namespace #>;

<#
    FileInfo thisFile = new FileInfo(Host.TemplateFile);
    ChinookDataSet ds = new ChinookDataSet();
    ds.ReadXml(thisFile.DirectoryName + @"\..\..\ChinookDatabase\DataSources\_Xml\ChinookData.xml");
#>
namespace ChinookDatabase.Test.DatabaseTests
{
    /// <summary>
    /// Test fixtures for <#= option.Name #> databases.
    /// </summary>
    [TestFixture]
    public class <#= className #>
    {
        static readonly IDictionary<string, <#= option.ConnectionClass #>> Connections = new Dictionary<string, <#= option.ConnectionClass #>>();

        /// <summary>
        /// Retrieves the cached connection object.
        /// </summary>
        /// <param name="connectionName">Connection name in the configuration file.</param>
        /// <returns>A connection object for this specific database.</returns>
        protected <#= option.ConnectionClass #> GetConnection(string connectionName)
        {
            // Creates an ADO.NET connection to the database, if not created yet.
            if (!Connections.ContainsKey(connectionName))
            {
                var section = (ConnectionStringsSection)ConfigurationManager.GetSection("connectionStrings");

                foreach (var entry in section.ConnectionStrings.Cast<ConnectionStringSettings>()
                                                                .Where(entry => entry.Name == connectionName))
                {
                    Connections[connectionName] = new <#= option.ConnectionClass #>(entry.ConnectionString);
                    break;
                }

                // If we failed to create a connection, then throw an exception.
                if (!Connections.ContainsKey(connectionName))
                    throw new ApplicationException("There is no connection string defined in app.config file.");
            }

            return Connections[connectionName];
        }

        /// <summary>
        /// Method to execute a SQL query and return a dataset.
        /// </summary>
        /// <param name="connectionName">Connection name in the configuration file.</param>
        /// <param name="query">Query string to be executed.</param>
        /// <returns>DataSet with the query results.</returns>
        protected DataSet ExecuteQuery(string connectionName, string query)
        {
            var dataset = new DataSet();
			var connection = GetConnection(connectionName);

            // Verify if number of entities match number of records.
            using (var adapter = new <#= option.AdapterClass #>(query, connection))
            {
                adapter.Fill(dataset);
            }

            return dataset;
        }
        
        #region Public Tests
        /// <summary>
        /// Verifies that the Unicode characters are populated properly.
        /// </summary>
        [Test]
        public void RecordsWithProperUnicodeCharacters([Values(<#= connectionValues #>)] string connectionName)
        {
<#
    for (int i=0; i < 10 || i < ds.Tables.Count; i++)
    {
		DataTable table = ds.Tables[i];
#>
			AssertThatCustomerId<#= i+1 #>HasProperUnicodeCharacters(connectionName);
<#
    } // foreach table
#>
        }

        /// <summary>
        /// Asserts that all invoices contain invoice lines.
        /// </summary>
        [Test]
        public void AllInvoicesMustHaveInvoiceLines([Values(<#= connectionValues #>)] string connectionName)
        {
            var dataSet = ExecuteQuery(connectionName, "SELECT count(InvoiceId) FROM Invoice WHERE InvoiceId NOT IN (SELECT InvoiceId FROM InvoiceLine GROUP BY InvoiceId)");
            Assert.That(dataSet.Tables[0].Rows[0][0], Is.EqualTo(0), "The number of invoices with no invoice lines must be zero.");
        }
        
        /// <summary>
        /// Asserts that invoice total matches sum of invoice lines.
        /// </summary>
        [Test]
        public void InvoiceTotalMustMatchSumOfInvoiceLines([Values(<#= connectionValues #>)] string connectionName)
        {
            var dataSet = ExecuteQuery(connectionName, "SELECT Invoice.InvoiceId, SUM(InvoiceLine.UnitPrice * InvoiceLine.Quantity) AS CalculatedTotal, Invoice.Total AS Total FROM InvoiceLine INNER JOIN Invoice ON InvoiceLine.InvoiceId = Invoice.InvoiceId GROUP BY Invoice.InvoiceId, Invoice.Total");

            foreach (DataRow row in dataSet.Tables[0].Rows)
            {
                Assert.That(row["CalculatedTotal"].ToString(), Is.EqualTo(row["Total"].ToString()), string.Format("The total field of InvoiceId={0} does not match its invoice lines.", row["InvoiceId"]));
            }
        }
<#
    foreach (DataTable table in ds.Tables)
    {
#>

        /// <summary>
        /// Verifies that the <#= table.TableName #> table was populated properly.
        /// </summary>
        [Test]
        public void <#= table.TableName #>TableShouldBePopulated([Values(<#= connectionValues #>)] string connectionName)
        {
            var dataSet = ExecuteQuery(connectionName, "SELECT * FROM <#= table.TableName #>");
            Assert.That(dataSet.Tables[0].Rows.Count, Is.EqualTo(<#= table.Rows.Count #>), "Total number of records mismatch.");
        }

        /// <summary>
        /// Verifies that last record of <#= table.TableName #> table has the proper information.
        /// </summary>
        [Test]
        public void <#= table.TableName #>LastRecordHasProperInfo([Values(<#= connectionValues #>)] string connectionName)
        {
            var dataSet = ExecuteQuery(connectionName, "SELECT * FROM <#= table.TableName #> ORDER BY <#= DataSetHelper.GetPrimaryKeyString (table) #>");
            var table = dataSet.Tables[0];
            Assert.IsNotNull(table);
            var row = table.Rows[table.Rows.Count - 1];
            Assert.IsNotNull(row);

			// Assert that the last record has the proper information.            
<#
		int num = table.Rows.Count - 1;
		foreach (DataColumn col in table.Columns)
		{
			string expected = DataSetHelper.GetExpectedValue(col, table.Rows[num][col.ColumnName].ToString());
#>            Assert.That(row["<#= col.ColumnName #>"].ToString(), Is.EqualTo(<#= expected #>), "<#= col.ColumnName #> mismatch.");
<#
		} // foreach column
#>        }
<#
    } // foreach table
#>
		#endregion

		#region Private Methods
<#
    for (int i=0; i < 10 || i < ds.Tables.Count; i++)
    {
		DataTable table = ds.Tables[i];
#>
        /// <summary>
        /// Verifies that CustomerId <#= i+1 #> has expected Unicode characters.
        /// </summary>
        private void AssertThatCustomerId<#= i+1 #>HasProperUnicodeCharacters(string connectionName)
        {
            var dataSet = ExecuteQuery(connectionName, "SELECT * FROM Customer WHERE CustomerId = <#= i+1 #>");
            Assert.That(dataSet.Tables[0].Rows.Count, Is.EqualTo(1), "Cannot find the Customer record that contains unicode characters. This record was not added to the Customer table or the SQL script did not use Unicode characters properly.");
            var row = dataSet.Tables[0].Rows[0];
            
<#
		foreach (DataColumn col in ds.Tables["Customer"].Columns)
		{
			string expected = DataSetHelper.GetExpectedValue(col, ds.Tables["Customer"].Rows[i][col.ColumnName].ToString());
#>            Assert.That(row["<#= col.ColumnName #>"].ToString(), Is.EqualTo(<#= expected #>), "<#= col.ColumnName #> mismatch.");
<#
		}
#>
		}

<#
    } // foreach table
#>
		#endregion
    }
}
<# 
	fileManager.EndBlock();
}

fileManager.Process(true);

#>
namespace ChinookDatabase.Test.DatabaseTests
{
    public class DatabaseFixture
    {
	}
}
<#+ 
	public class Option
	{
		public string Name { get; set; }
		public string ConnectionClass { get; set; }
		public string AdapterClass { get; set; }
		public string Namespace { get; set; }
		public IList<string> ConnectionNames { get; set; }
		
		public string GetConnectionValues()
		{
			char delimiter = ',';
			var builder = new StringBuilder();
			foreach(var name in ConnectionNames)
			{
				builder.AppendFormat("\"{0}\"{1} ", name, delimiter);
			}
			return builder.ToString().Trim().Trim(delimiter);
		}
	}
#>